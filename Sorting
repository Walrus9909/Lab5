import java.io.IOException;
import java.io.RandomAccessFile;
import java.lang.reflect.Array;
import java.text.SimpleDateFormat;
import java.util.Arrays;
import java.util.Calendar;

public class Sorting {

	/**
	 * 
	 * Sorts the numbers present in the file based on the algorithm provided. 0 =
	 * Arrays.sort() (Java Default) 1 = Bubble Sort 2 = Selection Sort 3 = Insertion
	 * Sort 4 = Mergesort 5 = Quicksort
	 *
	 * @param args the command-line arguments
	 */
	public static void main(String[] args) {
		In in = new In(args[0]);

		// Storing file input in an array
		int[] a = in.readAllInts();
		int[] b = preSort(a);
		int[] c = reverse(b);
		int[] d = almostSort(b);

		//Test
		 System.out.println(Arrays.toString(d));
//		 System.out.println(Arrays.toString(c));
//		 System.out.println(Arrays.toString(d));

		// TODO: Generate 3 other arrays, b, c, d where
		// b contains sorted integers from a (You can use Java Arrays.sort() method)
		// c contains all integers stored in reverse order
		// (you can have your own O(n) solution to get c from b
		// d contains almost sorted array
		// (You can copy b to a and then perform (0.1 * d.length) many swaps to acheive
		// this.

		// TODO:
		// Read the second argument and based on input select the sorting algorithm
		// * 0 = Arrays.sort() (Java Default)
		// * 1 = Bubble Sort
		// * 2 = Selection Sort
		// * 3 = Insertion Sort
		// * 4 = Mergesort
		// * 5 = Quicksort
		// Perform sorting on a,b,c,d. Pring runtime for each case along with timestamp
		// and record those.
		// For runtime and priting, you can use the same code from Lab 4 as follows:

		 
		 int sortChoice = Integer.parseInt(args[1]);
		 String sortType = null;
		 
			switch(sortChoice) {
			case 0:
				sortType = "Java Default";
				//Find out how long this takes
				
				break;
			case 1:
				sortType = "Bubble Sort";
				
				break;
			case 2:
				sortType = "Selection Sort";
				
				break;
			case 3:
				sortType = "Insertion Sort";
				
				break;
			case 4:
				sortType = "Merge Sort";
				
				break;
			case 5:
				sortType = "Quick Sort";
				
				break;
			
			}
		 
		 
		
		 
		// TODO: For each array, a, b, c, d:
		Stopwatch timer = new Stopwatch();
		// TODO: Perform Sorting and store the result in an array

		double time = timer.elapsedTimeMillis();

		String timeStamp = new SimpleDateFormat("yyyyMMdd_HHmmss").format(Calendar.getInstance().getTime());
		// TODO: Replace with your own netid
		String netID = "wwilli17";
		// TODO: Replace with the algorithm used
		String algorithmUsed =  sortType;
		// TODO: Replace with the array used
		String arrayUsed = "a";
		StdOut.printf("%s %s %8.1f   %s  %s  %s\n", algorithmUsed, arrayUsed, time, timeStamp, netID, args[0]);
		// Write the resultant array to a file (Each time you run a program 4 output
		// files should be generated. (one for each a,b,c, and d)

	}

	public static int[] preSort(int[] array) {
		Arrays.sort(array);
		return array;
	}

	public static int[] reverse(int[] array) {

		int counter = 0;
		int[] reversed = new int[array.length];
		for (int i = (array.length - 1); i >= 0; i--) {
			reversed[counter] = array[i];
			counter++;
		}
		return reversed;

	}

	public static int[] almostSort(int[] array) {

		double unsortDouble = (0.1 * array.length);
		int unsorts = (int) Math.round(unsortDouble);
		int[] unsorted = new int[array.length];
		for (int i = 0; i < array.length; i++) {
			unsorted[i] = array[i];
		}
		for (int i = 0; i <= unsorts; i++) {
			unsorted[(2 * i)] = array[(2 * i) + 1];
			unsorted[(2 * i) + 1] = array[2 * i];
		}
		return unsorted;
	}

	public static void createFile(String newFile) {

		try {
			RandomAccessFile raf = new RandomAccessFile(newFile, "rw");

		} catch (IOException ex) {
			ex.printStackTrace();
		}
	}

}
