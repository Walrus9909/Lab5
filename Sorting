/******************************************************************************
 *  Compilation:  javac Sorting.java
 *  Execution:    java Sorting input.txt AlgorithmUsed
 *  Dependencies: StdOut.java In.java Stopwatch.java
 *  Data files:   http://algs4.cs.princeton.edu/14analysis/1Kints.txt
 *                http://algs4.cs.princeton.edu/14analysis/2Kints.txt
 *                http://algs4.cs.princeton.edu/14analysis/4Kints.txt
 *                http://algs4.cs.princeton.edu/14analysis/8Kints.txt
 *                http://algs4.cs.princeton.edu/14analysis/16Kints.txt
 *                http://algs4.cs.princeton.edu/14analysis/32Kints.txt
 *                http://algs4.cs.princeton.edu/14analysis/1Mints.txt
 *
 *  A program to play with various sorting algorithms. 
 *
 *
 *  Example run:
 *  % java Sorting 2Kints.txt  2
 *
 ******************************************************************************/
import java.io.IOException;
import java.io.RandomAccessFile;
import java.lang.reflect.Array;
import java.text.SimpleDateFormat;
import java.util.Arrays;
import java.util.Calendar;

public class Sorting {

	/**
	 * 
	 * Sorts the numbers present in the file based on the algorithm provided. 0 =
	 * Arrays.sort() (Java Default) 1 = Bubble Sort 2 = Selection Sort 3 = Insertion
	 * Sort 4 = Mergesort 5 = Quicksort
	 *
	 * @param args the command-line arguments
	 */
	public static void main(String[] args) {
		In in = new In(args[0]);

		// Storing file input in an array
		int[] a = in.readAllInts();
		int[] b = preSort(a);
		int[] c = reverse(b);
		int[] d = almostSort(b);

		// TODO:
		// Read the second argument and based on input select the sorting algorithm
		// * 0 = Arrays.sort() (Java Default)
		// * 1 = Bubble Sort
		// * 2 = Selection Sort
		// * 3 = Insertion Sort
		// * 4 = Mergesort
		// * 5 = Quicksort
		// Perform sorting on a,b,c,d. Pring runtime for each case along with timestamp
		// and record those.
		// For runtime and priting, you can use the same code from Lab 4 as follows:

		
		int[][] traverse = new int[][] {a,b,c,d};
		String[] arrayNames = new String[] {"a","b","c","d"};
		String arrayUsed = null;
		String fileName = args[0];
		int sortChoice = Integer.parseInt(args[1]);
		String sortType = null;

		switch (sortChoice) {
		case 0:
			sortType = "Java Default";
			for (int i = 0; i < 4; i++) {
				arrayUsed = arrayNames[i];
				Stopwatch timer = new Stopwatch();
				javaDefault(traverse[i]);
				double time = timer.elapsedTimeMillis();
				System.out.println(time);
				results(sortType, time, arrayUsed, fileName);
			}
			break;
		case 1:
			sortType = "Bubble Sort";
			for (int i = 0; i < 4; i++) {
				arrayUsed = arrayNames[i];
				Stopwatch timer = new Stopwatch();
				bubbleSort(traverse[i]);
				double time = timer.elapsedTimeMillis();
				System.out.println(time);
				results(sortType, time, arrayUsed, fileName);
			}
			break;
		case 2:
			sortType = "Selection Sort";
			for (int i = 0; i < 4; i++) {
				arrayUsed = arrayNames[i];
				Stopwatch timer = new Stopwatch();
				selectionSort(traverse[i]);
				double time = timer.elapsedTimeMillis();
				System.out.println(time);
				results(sortType, time, arrayUsed, fileName);
			}
			break;
		case 3:
			sortType = "Insertion Sort";
			for (int i = 0; i < 4; i++) {
				arrayUsed = arrayNames[i];
				Stopwatch timer = new Stopwatch();
				insertionSort(traverse[i]);
				double time = timer.elapsedTimeMillis();
				System.out.println(time);
				results(sortType, time, arrayUsed, fileName);
			}
			break;
		case 4:
			sortType = "Merge Sort";

			break;
		case 5:
			sortType = "Quick Sort";
			for (int i = 0; i < 4; i++) {
				arrayUsed = arrayNames[i];
				Stopwatch timer = new Stopwatch();
				int low = 0;
				int high = traverse.length - 1;
				quickSort(traverse[i],low,high);
				double time = timer.elapsedTimeMillis();
				System.out.println(time);
				results(sortType, time, arrayUsed, fileName);
			}
			break;

		}

		

	}

	public static int[] preSort(int[] array) {
		Arrays.sort(array);
		return array;
	}

	public static int[] reverse(int[] array) {

		int counter = 0;
		int[] reversed = new int[array.length];
		for (int i = (array.length - 1); i >= 0; i--) {
			reversed[counter] = array[i];
			counter++;
		}
		return reversed;

	}

	public static int[] almostSort(int[] array) {

		double unsortDouble = (0.1 * array.length);
		int unsorts = (int) Math.round(unsortDouble);
		int[] unsorted = new int[array.length];
		for (int i = 0; i < array.length; i++) {
			unsorted[i] = array[i];
		}
		for (int i = 0; i <= unsorts; i++) {
			unsorted[(2 * i)] = array[(2 * i) + 1];
			unsorted[(2 * i) + 1] = array[2 * i];
		}
		return unsorted;
	}

	public static void createFile(String newFile) {

		try {
			RandomAccessFile raf = new RandomAccessFile(newFile, "rw");

		} catch (IOException ex) {
			ex.printStackTrace();
		}
	}

	public static void javaDefault(int[] array) {
		Arrays.sort(array);
	}

	public static void results(String sortType, double time, String arrayUsed, String fileName) {
		// TODO: For each array, a, b, c, d:
		// TODO: Perform Sorting and store the result in an array

		String timeStamp = new SimpleDateFormat("yyyyMMdd_HHmmss").format(Calendar.getInstance().getTime());
		String netID = "wwilli17";
		String algorithmUsed = sortType;
		// TODO: Replace with the array used
		StdOut.printf("%s %s %8.1f   %s  %s  %s\n", algorithmUsed, arrayUsed, time, timeStamp, netID, fileName);
		// Write the resultant array to a file (Each time you run a program 4 output
		// files should be generated. (one for each a,b,c, and d)
	}

	public static void bubbleSort(int arr[]) {
		int n = arr.length;
		for (int i = 0; i < n - 1; i++)
			for (int j = 0; j < n - i - 1; j++)
				if (arr[j] > arr[j + 1]) {
					// swap temp and arr[i]
					int temp = arr[j];
					arr[j] = arr[j + 1];
					arr[j + 1] = temp;
				}
	}
	
	public static void insertionSort(int arr[]) {
		int n = arr.length;
		for (int i = 1; i < n; ++i) {
			int key = arr[i];
			int j = i - 1;

			/*
			 * Move elements of arr[0..i-1], that are greater than key, to one position
			 * ahead of their current position
			 */
			while (j >= 0 && arr[j] > key) {
				arr[j + 1] = arr[j];
				j = j - 1;
			}
			arr[j + 1] = key;
		}
	}

	public static void selectionSort(int arr[]) {
		int n = arr.length;
		// One by one move boundary of unsorted subarray
		for (int i = 0; i < n - 1; i++) {
			// Find the minimum element in unsorted array
			int min_idx = i;
			for (int j = i + 1; j < n; j++)
				if (arr[j] < arr[min_idx])
					min_idx = j;

			// Swap the found minimum element with the first
			// element
			int temp = arr[min_idx];
			arr[min_idx] = arr[i];
			arr[i] = temp;
		}

	}

	public static int quickSortPartition(int arr[], int low, int high) {
		int pivot = arr[high];
		int i = (low - 1); // index of smaller element
		for (int j = low; j < high; j++) {
			// If current element is smaller than or
			// equal to pivot
			if (arr[j] <= pivot) {
				i++;

				// swap arr[i] and arr[j]
				int temp = arr[i];
				arr[i] = arr[j];
				arr[j] = temp;
			}
		}

		// swap arr[i+1] and arr[high] (or pivot)
		int temp = arr[i + 1];
		arr[i + 1] = arr[high];
		arr[high] = temp;

		return i + 1;
	}

	public static void quickSort(int arr[], int low, int high) {

		if (low < high) {
			/*
			 * pi is partitioning index, arr[pi] is now at right place
			 */
			int pi = quickSortPartition(arr, low, high);

			// Recursively sort elements before
			// partition and after partition
			quickSort(arr, low, pi - 1);
			quickSort(arr, pi + 1, high);
		}

	}
}
